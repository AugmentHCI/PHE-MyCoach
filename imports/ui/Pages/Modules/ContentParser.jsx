import { data } from 'browserslist';
import React, { useState } from 'react';
import './ContentParser.scss';

import Button from '../../components/Button.jsx';

function ContentParser(props) {

    /* Constructors for content */

    /**
     * Generates a Text-content HTML
     * @param {String} key The key of the HTML element generated by the parent
     * @param {String} text The text that needs to be displayed
     * @param {Boolean} isOverview True if the text is in an overview Card (will simply make text white)
     */
    function createTextContent(key, text, isOverview) {
        return <div key={key} className={isOverview ? "content-text-overview" : "content-text"}>{text}</div>;
    }

    /**
     * Generates a Question-content HTML 
     * @param {String} key The key of the HTML element generated by the parent
     * @param {String} question The question that is posed to the user
     * @param {Int} number (optional) The number of the question, used for the title
     * @param {Array[String]} options The possible options from which the user can choose to answer the question
     * @param {String} correct The correct option to the question
     * @param {String} explanation (optional) The explanation of the question that can be displayed after answering
     * @param {String} onCorrect The text that needs to be displayed (or added to the explanation) when the user answers correctly
     * @param {String} onIncorrect The text that needs to be displayed (or added to the explanation) when the user answers incorrectly
     */
    function createQuestionContent(key, question, number, options, correct, explanation, onCorrect, onIncorrect) {
        let buttonsHTML = [];
        let [status, changeStatus] =  useState("default");
        /* Make buttons for each of the options, and assign correct/incorrect actions to buttons */
        options.forEach((option, index) => {
            if (option === correct) {
                const correctButtonClass = status === "correct" ? "content-button-correct" : "content-button";
                buttonsHTML.push(<button key={key + "-" + index} className={correctButtonClass} onClick={() => {if (status === "default") changeStatus("correct")}}>{option}</button>);
            }
            else if (option !== correct) {
                const incorrectButtonClass = status === "incorrect" ? "content-button-incorrect" : "content-button";
                buttonsHTML.push(<button key={key + "-" + index} className={incorrectButtonClass} onClick={() => {if (status === "default") changeStatus("incorrect")}}>{option}</button>);
            }
        })
        /* Make the Question-Content element */
        return (<div key={key} className="content-question">
            <div className="content-question-title">Vraag {number ? number : ""}</div>
            <div className="content-question-text">{question}</div>
            <div className="content-buttons">{buttonsHTML}</div>
            {status === "correct" && <div className="content-answer-correct">{explanation ? onCorrect + " " + explanation : onCorrect}</div>}
            {status === "incorrect" && <div className="content-answer-incorrect">{explanation ? onIncorrect + " " + explanation : onIncorrect}</div>}
        </div>);
    };

        /**
     * Generates a Selection-content HTML 
     * @param {String} key The key of the HTML element generated by the parent
     * @param {String} title The title of the selection (empty string for no title, null for default 'Question')
     * @param {String} question The question that is posed to the user
     * @param {Array[String]} options The possible options from which the user can choose to answer the question
     */
    function createSelectionContent(key, title, question, options) {
        let buttonsHTML = [];
        const [selected, changeSelected] =  useState(new Array(options.length).fill(false));

        function selectButton(index) {
            let newArray = new Array(options.length).fill(false);
            newArray[index] = true;
            changeSelected(newArray);
        }
        /* Make buttons for each of the options, and assign correct/incorrect actions to buttons */
        options.forEach((option, index) => {
            buttonsHTML.push(<Button key={key + "-" + index} isSelected={selected[index]} action={() => selectButton(index)}>{option}</Button>);
        })
        /* Make the Question-Content element */
        return (<div key={key} className="content-question">
            {title !== "" && <div className="content-question-title">{title ? title : "Vraag"}</div>}
            <div className="content-question-text">{question}</div>
            <div className="content-buttons">{buttonsHTML}</div>
            {status === "correct" && <div className="content-answer-correct">{onCorrect}</div>}
            {status === "incorrect" && <div className="content-answer-incorrect">{onIncorrect}</div>}
        </div>);
    };

    /**
     * Generates a List-content HTML
     * @param {String} key The key of the HTML element generated by the parent
     * @param {Array[String]} content A string of text that will be enumerated
     * @param {Boolean} isNumbered True if the list is numbered, false if the list is bulleted
     * @param {Boolean} isOverview True if the list is in an overview Card (will simply make text white)
     */
    function createListContent(key, content, isNumbered, isOverview) {
        let listHTML = [];
        content.forEach((item, index) => {
            listHTML.push(<li key={key + "-" + index} className={isOverview ? "content-list-item-overview" : "content-list-item"}>{item}</li>)
        });
        if (isNumbered) return <ol className="content-list">{listHTML}</ol>;
        else return <ul className="content-list">{listHTML}</ul>;
    }

        /**
     * Generates a List-content HTML
     * @param {String} key The key of the HTML element generated by the parent
     * @param {String} imageUrl A string of text that will be enumerated
     * @param {Int} width (Optional) Percentage of width
     */
    function createImageContent(key, imageUrl, width) {
        /* If only one image url is given */
        if (!Array.isArray(imageUrl)) return <img className="content-image" src={imageUrl} width={width ? width + "%" : "80%"}/>;
        /* If an array of urls is given */
        let imageHTML = [];
        imageUrl.forEach((image, index) => {
            imageHTML.push(<img key={key+"-"+index} className="content-image-inline" src={image} width={90 / imageUrl.length + "%"}/>)
        })
        return imageHTML;
    }

    /**
     * Returns a Vimeo-iframe HTML
     * @param {String} key The key of the HTML element generated by the parent
     * @param {Dict} link A dictionary of language-keys and corresponding link-values
     * @param {String} language The language used as the key for the link dictionary
     */
    function createVideoContent(key, link, language) {
        if (link === false) {return <div className="content-video-todo">Video</div>}
        return <iframe key={key} src={link[language]} width="100%" style={{marginTop:"20px", borderRadius: "10px"}} frameBorder="0" allow="autoplay; fullscreen"></iframe>
    }


    /* Display-Rules */
    if (props.data["show-if"]) {
        if (props.data["show-if"] === "Pain" && props.userProfile.pain !== "Pain") return <React.Fragment></React.Fragment>;
        if (props.data["show-if"] === "No pain" && props.userProfile.pain !== "No pain") return <React.Fragment></React.Fragment>;
    }

    /* Generate content according to content type */
    switch (props.data.type) {
        case 'Text':
            return createTextContent(props.data.key, props.data.content, props.data.overview);
        case 'List':
            return createListContent(props.data.key, props.data.content, props.data.numbered, props.data.overview);
        case 'Question':
            return createQuestionContent(props.data.key, props.data.question, props.data.number, props.data.options, props.data.correct, props.data.explanation, props.data.onCorrect, props.data.onIncorrect);
        case 'Video':
            return createVideoContent(props.data.key, props.data.link, props.userProfile.language);
        case 'Selection':
            return createSelectionContent(props.data.key, props.data.title, props.data.question, props.data.options);
        case 'Image':
            return createImageContent(props.data.key, props.data.link, props.data.width);
        default:
            return <div className="content-not-implemented"><div className="content-not-implemented-title">NOT IMPLEMENTED</div>Hier komt een: {props.data.type}</div>
    }
}

export default ContentParser;